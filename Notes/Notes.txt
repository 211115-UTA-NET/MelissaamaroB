Day 1 
Desentrilized vs Centralized

Centralized
Main- SorT (source of truth) 


If there are more people working on somethings, they will all have to send their codes to the Main/ SorT
to keep the Main updated 
- ex. Once you send your code to the SorT then the SorT has to send the updated version to all other people.
	They would have to pull the updated version then continue to work then send their update to SorT
	which will continue the cycle of sending the updated version from one person to the whole group 
- Basically going back and forth w/ the SorT 
- Each person can only take to the SorT, not able to talk to each other
-Sending code to one place, if something goes wrong, everythig is lost 

De-centralized VCS (version control)
- Can talk to one person or to all
- If you don't have access to the latest/updated code 
- Everyone has a copy of the full set of code, even if one copy is bad, someone else has the copy that is fine
- You can code w/o the update
- Git is a de-centralized vcs (version control system) 

GitBAsh
The top amaro@LAPTOP-J82NR8BR (name of computer)
MINGW64- what we are working on
siggly line - it is where your home directory will be 
- your starting ponit/ homedirectory 
- HOME 

Shorthands 

Pushing the up arrow copies and paste it to the new line :)
By hitting tsb it can autofill
pwd - current working directory 
usually - /c/users/Melissaamaro
cd .. - this will change the directory to the parent directory 
- ex. /c/users 
cd . - start here 
- period is a shorthand to say go there to the file you place ( cd./Melissaamaro)
ls - list the contents in the folder 
ls -a - this shows hidden folders. If it is a repository it will have .git/
to change directory 
cd ./Downloads 
cd ~ - goes to main 
mkdir - make directory/makes a folder inside the main directory (Melissaamaro)
touch - makes a new file (has to add an extension) ex. example.txt 
rm - this deltes the file in the folder we are in 
- ex. rm example.txt 
- after inputting, gitbash will not show if it occured or not so just to make sure do (ls) to see if it is no longer there 
- can only delete files 
rm -r 
- (-r) is considered a flag, so now there is a command and a falg with a target 
- r flag is recursise, deleting everything in that location and the location itself 
- this will delete a directory 
- you can delte a folder and file from a different directory ( ex. rm -r ../namefolder/text.md) this will delte the file in that folder 
- -r is not needed when deleting a single file 
- rm -r(-i) confirms the command b4 executing 
- Command explorer - opens folder 
- Explore - open a file explorer to the target location 
- cat = reads what os inside a file 
-clear = clears the screen, still in the folr you were working on
-start = Open a file from a folder on git
- echo "Hello"  = with "" shows bash that it is all one thing, in a string
- echo "" > test.tex = (>) tells to print the echo into this file 
- > = will overwrite whatever is in that file with what you wrote
	ex. echo "hello" > test.txt 
	Hello 
- >> = will append, or move to the end of the file, so adding lines to the file instead of overwriting it 
	ex. echo "hello again" >> test.txt 
	Hello
	Hello again
- which - help us learn if we have something installed//print the location of the exectuable// prints $PATH
	which git 
	/mingw64/bin/git (shows where it is) 
- (-- version) = shows what version of a software you have // the flag commonly prints out the version of a utility 
	git --version
	(shows version)
- head = shows the 10 lines in there 
- head -3 = shows the first 3 by default
- .sh (where we can use it to write commands besides gitbash) 
	#!user/bin/bash - what to put on file so that it can read on gitbash 
- .txt (notes where there is text) 
- variable= (name) after the equal sign is the variable
Graphical UI (how you do actions by hand) 
1. find the file in its folder 
2. right click on the file, choose an option 
Command Line (how you do things in code) 
1. actions
2. options
3. target \
- action (delete (rm) options (-r) target (directory) 

--help
cd [L...][direc] (shows you the falgs and where it is going 

Repository 
git clone "link"
- only need to clone once to get that reposiroty, after that you can pull/copy things by just going to the repositoy folder and gitpull 

- you can add a file into a folder when inside another folder 

- can also list whats in another folder while in another folder 
ls ./foldername/text.txt

git clone- creates and initializes a copy of a remote repo to a local location 


Hack Rank :
for Loops 
// Loop 1-50 (range style for loop) 
CODE:
for x in (1..50)         // the variable x inside (1-50) (..) = change number 
do                       // opens the command funtion on what we will do 
	echo $x                  // echo write's a string for the variable on a file   
done 			// closes out the function 

Skipping Loops
for Loops in shell
//1-99 , get odd 
CODE:
for i in (1..99..2) // 2 is how much it is incrimenting per number, making it odd 
do 
	echo $i
done 

for loops in C# CODE:
for ((i=1; i<100; i+=2)      // i is the variable and it letting C# know that it will start with 1 and will be less than 100 numbers, and we add 
				2 to each number. 
do 
echo $i
done 

Comparing Variables 
// Two variable X & Y, compare the two with >,<,=
CODE 1:
read = x
read = y
if (( $x < $y ))              	 	//comparing the two values 
then
	echo "x is less then y"
elif (( $x > $y )) 			// if-else: continue on; testing a second condition 
then 
	echo "x is greater than y"
else 					// to catch the last string; if both are false then this last one is true 
	echo "x is equal to y" 
fi 
Diff. Commands for comparing for Bash 
	-le (less than < or equal to) 
	- ge (greater than > or equal to)
CODE 2:
read x
read y

if [ $x -ge $y ]
then
    echo "X is greater than Y"
fi

if [ $x = $y ]
then 
    echo "X is equal to Y"
fi

if [ $x -le $y ]
then 
    echo "X is less than Y"
fi
 

Conditionals
if (( $x == Y )) || (( $x == y))
then
	echo ""
elif (( $x == N )) || (( $x == n ))
then
echo 

|| - or statement 

The flow of a loop/ setup: Comparing 
start -> read input -> if y or n -> (2 options: y // n) -> y = echo yes & n = echo no 

	read options 

Conditionals - if/else-f /else 
start -> read value -> action -> check condition -> exit 
			(if not met)<-		(if met)
Conditionals - if/else-if /else 
- if = testing if a comparison is true or not 
- else-if (elif) = testing if a second comparison is true 
- else = If all else fails, do this 

== - is it equal to b (equal sign) 
	if [ a == b ]; then
	do this stuff
	fi 
> or < - if greater than or less than 
>= or <= - '' or euqual to 
!= - if a is not equal to b 
	if [a !=b ]; then
	do this stuff
	fi 

|| - logical or 
- only one of the statements needs to be true to be true 
- A boolean (two options) 
1= true/yes/on
2= false/no/off 
0 || 0 = 0
1 || 0 = 1
0 || 1 = 1
1 || 1 = 1

&& - logical and 
- between two things, both must be true to say be true 
0 && 0 = 0
1 && 0 = 0 
0 && 1 = 0
1 && 1 = 1

4/2=2
3/2=1.5
modules operator- to help with counting etc 
% - return only the remainder = only whole numbers, no decimals 
- ex.
3/2 = 1.5 (% of 1) 


an isolated comaprison needs a double bracket, especially when doing an if statement. 
newar = null



